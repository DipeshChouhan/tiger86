// Author: Dipesh Chouhan

// Bus interface unit (BIU) of 8086 processor
const std = @import("std");

// fix capacity of 6 as 8086 processor has instruction queue of size 6
const instQueueCapacity: u8 = 6;
pub const InstructionQueue = struct {
    data: [6]u8,
    len: u8,
    head: u8,
    tail: u8,

    pub fn init() InstructionQueue {
        return InstructionQueue{ .data = undefined, .len = 0, .head = 0, .tail = 0 };
    }
};

// the size can't be greater than 6
pub inline fn instQueueAdd(queue: *InstructionQueue, inst: u8) void {
    queue.data[queue.tail] = inst;
    queue.len += 1;
    queue.tail = (queue.tail + 1) % instQueueCapacity;
}

pub inline fn instQueueFetch(queue: *InstructionQueue) u8 {
    const inst = queue.data[queue.head];

    queue.len -= 1;
    queue.head = (queue.head + 1) % instQueueCapacity;
    return inst;
}
pub var Biu = struct {

    // segment registers
    cs: u16,
    ds: u16,
    ss: u16,
    es: u16,

    // instruction pointer
    ip: u16,

    // 20bit address bus
    add_bus: u32,

    // instruction queue
    inst_queue: InstructionQueue,

    // TODO: initialize the registers according to the 8086 reset behaviour
    pub fn init() Biu {
        return Biu{
            .cs = 0,
            .ds = 0,
            .ss = 0,
            .es = 0,
            .ip = 0,
            .add_bus = 0,
            .inst_queue = InstructionQueue.init(),
        };
    }

    // TODO: implement instruction prefetching
    pub fn fetch(self: *Biu) u8 {
        return instQueueFetch(&self.inst_queue);
    }
};

// --------------------------------------------------

// the tests are auto generated by windsurf plugin

test "instQueueAdd" {
    var queue = InstructionQueue.init();
    instQueueAdd(&queue, 0b1000_0000);
    instQueueAdd(&queue, 0b0100_0000);
    instQueueAdd(&queue, 0b0010_0000);
    instQueueAdd(&queue, 0b0001_0000);
    instQueueAdd(&queue, 0b0000_1000);
    instQueueAdd(&queue, 0b0000_0100);
    try std.testing.expectEqual(queue.len, 6);
    try std.testing.expectEqual(queue.head, 0);
    try std.testing.expectEqual(queue.tail, 0);
}

test "instQueueFetch" {
    var queue = InstructionQueue.init();
    instQueueAdd(&queue, 0b1000_0000);
    instQueueAdd(&queue, 0b0100_0000);
    instQueueAdd(&queue, 0b0010_0000);
    instQueueAdd(&queue, 0b0001_0000);
    instQueueAdd(&queue, 0b0000_1000);
    instQueueAdd(&queue, 0b0000_0100);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b1000_0000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0100_0000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0010_0000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0001_0000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0000_1000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0000_0100);
    try std.testing.expectEqual(queue.len, 0);
    try std.testing.expectEqual(queue.head, 0);
    try std.testing.expectEqual(queue.tail, 0);
}

test "instQueueAdd and instQueueFetch" {
    var queue = InstructionQueue.init();
    instQueueAdd(&queue, 0b1000_0000);
    instQueueAdd(&queue, 0b0100_0000);
    instQueueAdd(&queue, 0b0010_0000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b1000_0000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0100_0000);
    instQueueAdd(&queue, 0b0001_0000);
    instQueueAdd(&queue, 0b0000_1000);
    instQueueAdd(&queue, 0b0000_0100);

    try std.testing.expectEqual(queue.len, 4);

    try std.testing.expectEqual(instQueueFetch(&queue), 0b0010_0000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0001_0000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0000_1000);
    try std.testing.expectEqual(instQueueFetch(&queue), 0b0000_0100);
    try std.testing.expectEqual(queue.len, 0);
    try std.testing.expectEqual(queue.head, 0);
    try std.testing.expectEqual(queue.tail, 0);
}
